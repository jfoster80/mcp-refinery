/**
 * Code Agent â€” produces PRs for improvement proposals.
 *
 * Agents never push to main. All changes land as PRs with appropriate
 * metadata, branch naming, and commit messages.
 */

import { randomUUID } from 'node:crypto';
import type { PullRequestRecord, DeliveryPlan, ImprovementProposal } from '../types/index.js';
import { getDeliveryPlan, getProposal, insertPullRequest, updateProposalStatus, recordAudit } from '../storage/index.js';

export interface PRInput {
  plan_id: string;
  proposal_ids: string[];
  repo_url: string;
  base_branch?: string;
  changes_summary: string;
  diff_stats?: { files_changed: number; additions: number; deletions: number };
}

/**
 * Create a PR record for a set of proposals within a delivery plan.
 */
export function createPRRecord(input: PRInput): PullRequestRecord {
  const plan = getDeliveryPlan(input.plan_id);
  if (!plan) throw new Error(`Delivery plan ${input.plan_id} not found`);

  const proposals: ImprovementProposal[] = [];
  for (const id of input.proposal_ids) {
    const p = getProposal(id);
    if (p) proposals.push(p);
  }

  const branchName = generateBranchName(proposals);
  const title = generatePRTitle(proposals);
  const description = generatePRDescription(proposals, plan, input.changes_summary);

  const pr: PullRequestRecord = {
    pr_id: randomUUID(),
    plan_id: input.plan_id,
    proposal_ids: input.proposal_ids,
    repo_url: input.repo_url,
    branch_name: branchName,
    pr_number: null,
    pr_url: null,
    title,
    description,
    diff_stats: input.diff_stats ?? { files_changed: 0, additions: 0, deletions: 0 },
    status: 'draft',
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  };

  insertPullRequest(pr);

  for (const id of input.proposal_ids) {
    updateProposalStatus(id, 'pr_open');
  }

  recordAudit(
    'delivery.pr_created',
    'code_agent',
    'pull_request',
    pr.pr_id,
    {
      branch: branchName,
      proposals: input.proposal_ids,
      plan_id: input.plan_id,
      repo_url: input.repo_url,
    },
  );

  return pr;
}

function generateBranchName(proposals: ImprovementProposal[]): string {
  const prefix = 'refinery';
  if (proposals.length === 1) {
    const slug = proposals[0].title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .slice(0, 50)
      .replace(/-$/, '');
    return `${prefix}/${proposals[0].category}/${slug}`;
  }
  const categories = [...new Set(proposals.map((p) => p.category))];
  const dateSlug = new Date().toISOString().slice(0, 10);
  return `${prefix}/${categories.join('-')}/${dateSlug}`;
}

function generatePRTitle(proposals: ImprovementProposal[]): string {
  if (proposals.length === 1) {
    return `[Refinery] ${proposals[0].title}`;
  }
  const categories = [...new Set(proposals.map((p) => p.category))];
  return `[Refinery] ${proposals.length} improvements (${categories.join(', ')})`;
}

function generatePRDescription(
  proposals: ImprovementProposal[],
  plan: DeliveryPlan,
  changesSummary: string,
): string {
  const proposalList = proposals.map((p) =>
    `- **${p.title}** (${p.category}, risk: ${p.risk_level})\n  ${p.description.split('\n')[0]}`,
  ).join('\n');

  return `## MCP Refinery Automated Improvement

### Changes Summary
${changesSummary}

### Proposals Addressed
${proposalList}

### Delivery Plan
- **Plan ID**: ${plan.plan_id}
- **Estimated Duration**: ${plan.estimated_duration_hours}h
- **Status**: ${plan.status}

### Test Strategy
${plan.test_strategy}

### Rollback Plan
${plan.rollback_plan}

### Acceptance Criteria
${proposals.flatMap((p) => p.acceptance_criteria.map((c) => `- [ ] ${c}`)).join('\n')}

---
*This PR was generated by MCP Refinery. All changes have been triaged through the policy engine, checked against anti-oscillation rules, and planned through the governance-aware delivery pipeline.*
`;
}

/**
 * Generate a structured commit message for refinery changes.
 */
export function generateCommitMessage(proposals: ImprovementProposal[]): string {
  if (proposals.length === 1) {
    const p = proposals[0];
    return `refinery(${p.category}): ${p.title.slice(0, 72)}\n\nProposal: ${p.proposal_id}\nRisk: ${p.risk_level}\n\n${p.description}`;
  }

  const summary = `refinery: ${proposals.length} improvements`;
  const body = proposals.map((p) => `- [${p.category}] ${p.title} (${p.proposal_id})`).join('\n');
  return `${summary}\n\n${body}`;
}
